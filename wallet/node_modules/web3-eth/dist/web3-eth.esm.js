import { formatters } from 'web3-core-helpers';
import { SubscriptionsFactory } from 'web3-core-subscriptions';
import { Accounts } from 'web3-eth-accounts';
import { Ens } from 'web3-eth-ens';
import { ContractModuleFactory } from 'web3-eth-contract';
import { Personal } from 'web3-eth-personal';
import { AbiCoder } from 'web3-eth-abi';
import { Iban } from 'web3-eth-iban';
import { ProvidersModuleFactory } from 'web3-providers';
import { Network } from 'web3-net';
import * as Utils from 'web3-utils';
import Nat from 'eth-lib/lib/nat';
import Bytes from 'eth-lib/lib/bytes';
import Hash from 'eth-lib/lib/hash';
import RLP from 'eth-lib/lib/rlp';
import Account from 'eth-lib/lib/account';
import { AbstractWeb3Module } from 'web3-core';
import { AbstractMethodFactory, GetNodeInfoMethod, GetProtocolVersionMethod, GetCoinbaseMethod, IsMiningMethod, GetHashrateMethod, IsSyncingMethod, GetGasPriceMethod, GetAccountsMethod, GetBlockNumberMethod, GetBalanceMethod, GetStorageAtMethod, GetCodeMethod, GetBlockMethod, GetUncleMethod, GetBlockTransactionCountMethod, GetBlockUncleCountMethod, GetTransactionMethod, GetTransactionFromBlockMethod, GetTransactionReceipt, GetTransactionCountMethod, SendRawTransactionMethod, SignTransactionMethod, SendTransactionMethod, SignMethod, CallMethod, EstimateGasMethod, SubmitWorkMethod, GetWorkMethod, GetPastLogsMethod, RequestAccountsMethod, VersionMethod, ChainIdMethod, MethodModuleFactory } from 'web3-core-method';

class TransactionSigner {
  constructor(utils, formatters$$1) {
    this.utils = utils;
    this.formatters = formatters$$1;
  }
  async sign(transaction, privateKey) {
    if (!privateKey) {
      throw new Error('No privateKey given to the TransactionSigner.');
    }
    if (privateKey.startsWith('0x')) {
      privateKey = privateKey.substring(2);
    }
    transaction = this.formatters.txInputFormatter(transaction);
    transaction.to = transaction.to || '0x';
    transaction.data = transaction.data || '0x';
    transaction.value = transaction.value || '0x';
    transaction.chainId = this.utils.numberToHex(transaction.chainId);
    const rlpEncoded = this.createRlpEncodedTransaction(transaction);
    const hash = Hash.keccak256(rlpEncoded);
    const signature = this.createAccountSignature(hash, privateKey, transaction.chainId);
    const rawTransaction = RLP.encode(this.mapRlpEncodedTransaction(rlpEncoded, signature));
    const values = RLP.decode(rawTransaction);
    return {
      messageHash: hash,
      v: this.trimLeadingZero(values[6]),
      r: this.trimLeadingZero(values[7]),
      s: this.trimLeadingZero(values[8]),
      rawTransaction
    };
  }
  createRlpEncodedTransaction(transaction) {
    return RLP.encode([Bytes.fromNat(transaction.nonce), Bytes.fromNat(transaction.gasPrice), Bytes.fromNat(transaction.gas), transaction.to.toLowerCase(), Bytes.fromNat(transaction.value), transaction.data, Bytes.fromNat(transaction.chainId), '0x', '0x']);
  }
  createAccountSignature(hash, privateKey, chainId) {
    return Account.makeSigner(Nat.toNumber(chainId) * 2 + 35)(hash, privateKey);
  }
  mapRlpEncodedTransaction(rlpEncoded, signature) {
    const rawTransaction = RLP.decode(rlpEncoded).slice(0, 6).concat(Account.decodeSignature(signature));
    rawTransaction[6] = this.makeEven(this.trimLeadingZero(rawTransaction[6]));
    rawTransaction[7] = this.makeEven(this.trimLeadingZero(rawTransaction[7]));
    rawTransaction[8] = this.makeEven(this.trimLeadingZero(rawTransaction[8]));
    return rawTransaction;
  }
  trimLeadingZero(hex) {
    while (hex && hex.startsWith('0x0')) {
      hex = `0x${hex.slice(3)}`;
    }
    return hex;
  }
  makeEven(hex) {
    if (hex.length % 2 === 1) {
      hex = hex.replace('0x', '0x0');
    }
    return hex;
  }
}

class Eth extends AbstractWeb3Module {
  constructor(provider, providersModuleFactory, methodModuleFactory, methodFactory, net, accounts, personal, Iban$$1, abiCoder, ens, utils, formatters$$1, subscriptionsFactory, contractModuleFactory, transactionSigner, options, nodeNet) {
    super(provider, providersModuleFactory, methodModuleFactory, methodFactory, options, nodeNet);
    this.net = net;
    this.accounts = accounts;
    this.personal = personal;
    this.Iban = Iban$$1;
    this.abi = abiCoder;
    this.ens = ens;
    this.utils = utils;
    this.formatters = formatters$$1;
    this.subscriptionsFactory = subscriptionsFactory;
    this.contractModuleFactory = contractModuleFactory;
    this.initiatedContracts = [];
    this._transactionSigner = options.transactionSigner || transactionSigner;
    this.Contract = (abi, address, options = {}) => {
      options.transactionSigner = this.transactionSigner;
      const contract = this.contractModuleFactory.createContract(this.currentProvider, this.providersModuleFactory, this.accounts, abi, address, options);
      this.initiatedContracts.push(contract);
      return contract;
    };
  }
  get transactionSigner() {
    return this._transactionSigner;
  }
  set transactionSigner(transactionSigner) {
    this._transactionSigner = transactionSigner;
    this.accounts.transactionSigner = transactionSigner;
    this.ens.transactionSigner = transactionSigner;
    this.initiatedContracts.forEach(contract => {
      contract.transactionSigner = transactionSigner;
    });
  }
  clearSubscriptions() {
    return super.clearSubscriptions('eth_unsubscribe');
  }
  set defaultGasPrice(value) {
    this.initiatedContracts.forEach(contract => {
      contract.defaultGasPrice = value;
    });
    this.net.defaultGasPrice = value;
    this.personal.defaultGasPrice = value;
    super.defaultGasPrice = value;
  }
  get defaultGasPrice() {
    return super.defaultGasPrice;
  }
  set defaultGas(value) {
    this.initiatedContracts.forEach(contract => {
      contract.defaultGas = value;
    });
    this.net.defaultGas = value;
    this.personal.defaultGas = value;
    super.defaultGas = value;
  }
  get defaultGas() {
    return super.defaultGas;
  }
  set transactionBlockTimeout(value) {
    this.initiatedContracts.forEach(contract => {
      contract.transactionBlockTimeout = value;
    });
    this.net.transactionBlockTimeout = value;
    this.personal.transactionBlockTimeout = value;
    super.transactionBlockTimeout = value;
  }
  get transactionBlockTimeout() {
    return super.transactionBlockTimeout;
  }
  set transactionConfirmationBlocks(value) {
    this.initiatedContracts.forEach(contract => {
      contract.transactionConfirmationBlocks = value;
    });
    this.net.transactionConfirmationBlocks = value;
    this.personal.transactionConfirmationBlocks = value;
    super.transactionConfirmationBlocks = value;
  }
  get transactionConfirmationBlocks() {
    return super.transactionConfirmationBlocks;
  }
  set transactionPollingTimeout(value) {
    this.initiatedContracts.forEach(contract => {
      contract.transactionPollingTimeout = value;
    });
    this.net.transactionPollingTimeout = value;
    this.personal.transactionPollingTimeout = value;
    super.transactionPollingTimeout = value;
  }
  get transactionPollingTimeout() {
    return super.transactionPollingTimeout;
  }
  set defaultAccount(value) {
    this.initiatedContracts.forEach(contract => {
      contract.defaultAccount = this.utils.toChecksumAddress(value);
    });
    this.net.defaultAccount = value;
    this.personal.defaultAccount = value;
    super.defaultAccount = value;
  }
  get defaultAccount() {
    return super.defaultAccount;
  }
  set defaultBlock(value) {
    this.initiatedContracts.forEach(contract => {
      contract.defaultBlock = value;
    });
    this.net.defaultBlock = value;
    this.personal.defaultBlock = value;
    super.defaultBlock = value;
  }
  get defaultBlock() {
    return super.defaultBlock;
  }
  subscribe(type, options, callback) {
    switch (type) {
      case 'logs':
        return this.subscriptionsFactory.createLogSubscription(options, this, this.methodFactory.createMethod('getPastLogs')).subscribe(callback);
      case 'newBlockHeaders':
        return this.subscriptionsFactory.createNewHeadsSubscription(this).subscribe(callback);
      case 'pendingTransactions':
        return this.subscriptionsFactory.createNewPendingTransactionsSubscription(this).subscribe(callback);
      case 'syncing':
        return this.subscriptionsFactory.createSyncingSubscription(this).subscribe(callback);
      default:
        throw new Error(`Unknown subscription: ${type}`);
    }
  }
  setProvider(provider, net) {
    const setContractProviders = this.initiatedContracts.every(contract => {
      return contract.setProvider(provider, net);
    });
    return this.net.setProvider(provider, net) && this.personal.setProvider(provider, net) && super.setProvider(provider, net) && setContractProviders;
  }
}

class MethodFactory extends AbstractMethodFactory {
  constructor(methodModuleFactory, utils, formatters$$1) {
    super(methodModuleFactory, utils, formatters$$1);
    this.methods = {
      getNodeInfo: GetNodeInfoMethod,
      getProtocolVersion: GetProtocolVersionMethod,
      getCoinbase: GetCoinbaseMethod,
      isMining: IsMiningMethod,
      getHashrate: GetHashrateMethod,
      isSyncing: IsSyncingMethod,
      getGasPrice: GetGasPriceMethod,
      getAccounts: GetAccountsMethod,
      getBlockNumber: GetBlockNumberMethod,
      getBalance: GetBalanceMethod,
      getStorageAt: GetStorageAtMethod,
      getCode: GetCodeMethod,
      getBlock: GetBlockMethod,
      getUncle: GetUncleMethod,
      getBlockTransactionCount: GetBlockTransactionCountMethod,
      getBlockUncleCount: GetBlockUncleCountMethod,
      getTransaction: GetTransactionMethod,
      getTransactionFromBlock: GetTransactionFromBlockMethod,
      getTransactionReceipt: GetTransactionReceipt,
      getTransactionCount: GetTransactionCountMethod,
      sendSignedTransaction: SendRawTransactionMethod,
      signTransaction: SignTransactionMethod,
      sendTransaction: SendTransactionMethod,
      sign: SignMethod,
      call: CallMethod,
      estimateGas: EstimateGasMethod,
      submitWork: SubmitWorkMethod,
      getWork: GetWorkMethod,
      getPastLogs: GetPastLogsMethod,
      requestAccounts: RequestAccountsMethod,
      getId: VersionMethod,
      getChainId: ChainIdMethod
    };
  }
}

const TransactionSigner$1 = () => {
  return new TransactionSigner(Utils, formatters);
};
const MethodFactory$1 = () => {
  return new MethodFactory(new MethodModuleFactory(), Utils, formatters);
};
const Eth$1 = (provider, net, options) => {
  const accounts = new Accounts(provider, options);
  const abiCoder = new AbiCoder();
  const methodModuleFactory = new MethodModuleFactory();
  return new Eth(provider, new ProvidersModuleFactory(), methodModuleFactory, new MethodFactory$1(), new Network(provider, options), accounts, new Personal(provider, accounts, options), Iban, abiCoder, new Ens(provider, accounts, options), Utils, formatters, new SubscriptionsFactory(), new ContractModuleFactory(Utils, formatters, abiCoder, accounts, methodModuleFactory), new TransactionSigner$1(), options, net);
};

export { TransactionSigner$1 as TransactionSigner, MethodFactory$1 as MethodFactory, Eth$1 as Eth };
